@page "/methods/channel-access"
@using BlazorApexCharts.Docs.Data
@using System.Timers
@using Clf.ChannelAccess
@implements IDisposable

<h3>ChannelAccess</h3>
<DemoContainer>
  <ApexChart @ref=chart TItem="RealTimeSeries"
             Title="@_streamChannel.ChannelName.Name"
             XAxisType="XAxisType.Datetime"
             Options=options>

    <ApexPointSeries TItem="RealTimeSeries"
                     Items="generator.TimeSeries"                 
                     SeriesType="SeriesType.Line"
                     Color="Blue"
                     Name="Field Strength"
                     XValue="@(e => e.Date)"
                     YValue="@(e => e.Value)"
                     OrderBy="e=>e.X" />
    <!-- ApexPointSeries TItem="RealTimeSeries"
                     Items="generator.BaselineSeries"
                     SeriesType="SeriesType.Line"
                     Color="Black"
                     XValue="_AT(e => e.Date)"
                     YValue="_AT(e => e.Value)"
                     OrderBy="e=>e.X" / -->

  </ApexChart>
</DemoContainer>

@code {
  //NOTE: ~ dataPoints for LaserShot events to draw a vertical slice.

  //NOTE: ~  There is Dark/light theming

  private ApexChart<RealTimeSeries> chart;
  private ApexChartOptions<RealTimeSeries> options;
  private RealTimeSeriesGenerator generator = new RealTimeSeriesGenerator(60);
  private bool timerInitialized = false;
  private Timer timer;
  private DateTimeOffset maxTime;
  private int counter;
  private List<MagneticResult> dataset = new List<MagneticResult>();
  private ChannelsHandler _channelsHandler = new ChannelsHandler();
  IChannel _streamChannel = null;
  double _myValue;
  string _myUnit = " ";
  string _lastUnit;
  string _csvExportFileName = "C:/Temp/gaussData.";

  //TODO: Below for async event based timing - as per EventSpawned providing rather than consuming values.
  //protected override async Task OnInitializedAsync()   
  protected override void OnInitialized()
  {
    //Hook to channel access!!!!!
    _channelsHandler.InstallChannel(_streamChannel = Hub.GetOrCreateChannel("BENCH:HIRST1:val"),
      (isConnected, state) => { if (isConnected) timerInitialized = true; },
      (valueInfo, _) => { _myValue = (double)valueInfo.Value; _myUnit = EventSpawned(valueInfo.AuxiliaryInfo.EGU); });

    options = new ApexChartOptions<RealTimeSeries>();

    options.Xaxis = new XAxis
      {
        Title = new AxisTitle() { Text = "Time (sec) - Commenced @ " + DateTime.Now.ToString("G") },
        Range = generator.Range
      };
    options.Tooltip = new ApexCharts.Tooltip { X = new TooltipX { Format = @"dd/MM/yyyy hh:mm:ss" } };
    
    options.Tooltip = new ApexCharts.Tooltip()
      {
        FollowCursor = true,
        Theme = Mode.Light,
        Y = new TooltipY()
      };

    options.Yaxis = new List<YAxis> {
            new YAxis {
              Title = new AxisTitle() { Text = "Intensity (" + _myUnit + ")"},
              Max = 30,
              Min = -30 }
        };
    options.Stroke = new Stroke { Curve = Curve.Smooth };
    options.Chart = new Chart
      {
        Animations = new Animations
        {
          Easing = Easing.Linear,
          DynamicAnimation = new DynamicAnimation
          {
            Speed = 950
          }
        },
        Toolbar = new Toolbar
        {
          Show = false,
          Export = new ExportOptions
          {
            Csv = new ExportCSV
            {
              Filename = _csvExportFileName + ".csv",
              HeaderCategory = "Magnetic data",
            },
            Png = new ExportPng { Filename = _csvExportFileName + ".png" },
            Svg = new ExportSvg { Filename = _csvExportFileName + ".svg" }
          }
      },
      Zoom = new Zoom
      {
        Enabled = true, 
        AutoScaleYaxis = false
      }
    };
  }

  //REFACTOR: Just return the unit, this is an exploration hook for debug.
  protected string EventSpawned(string unit) 
  {
    if (_lastUnit != unit)
    {
      _lastUnit = unit;
      Task.Run(() => BlankGraph());
    }
    return unit;  
  }

  protected override void OnAfterRender(bool firstRender)
  {
    if (firstRender && !timerInitialized)
    {
      timerInitialized = true;
      timer = new Timer(333);
      timer.Elapsed += async delegate { await UpdateChartSeries(); };
      timer.Enabled = true;
    }
  }

  private async Task UpdateChartSeries()
  {
    //TODO: Might want to key this to a timeStamp for Kafka?
    try
    {
      if (counter > 21600) //Reset the chart at 6 hours - maximal run  TS: 15-Feb-2024
      {
        await BlankGraph();
      }

      //if (maxTime == DateTimeOffset.MinValue)
      //{
      //maxTime = generator.TimeSeries.Max(e => e.Date);
      //}

      maxTime = maxTime.AddSeconds(1);
      await chart.AppendDataAsync(
        new List<RealTimeSeries> { 
          generator.GenerateNewPoint(maxTime, _myValue)
        }
      );
      counter++;
    }
    catch (Exception ex)
    {
      //6hour runtime
      Console.WriteLine(ex.Message);
    }
  }

  private async Task BlankGraph()
  {
    counter = 0; //Zero counter as we are scaling at a different unit now

    if (chart != null) {
      Console.WriteLine(chart.Series[0].XValue.ToString());
      Console.WriteLine(chart.Series[0].Chart.Title);

      chart.Series[0].Color = "Blue";
      chart.Series[0].Stroke = new SeriesStroke() { Color = "Blue" };

      chart.Options.Tooltip.Y = new TooltipY
        {
          Title = new TooltipYTitle { Formatter = @"function(name) { return name + ':' }" },
          Formatter = @"function(value, { series, seriesIndex, dataPointIndex, w }) { return (Math.round(value * 100) / 100).toFixed(2) + _myUnits}"
        };

      //Sync after units change
      chart.Options.Xaxis.Title = new AxisTitle() { Text = "Time (sec) - Commenced @ " + DateTime.Now.ToString("G") };
      //chart.Options.Title = new Title() { Text = TITLE_PREFIX + " (" + _myUnit + ")"};
      chart.Options.Yaxis[0].Title = new AxisTitle() { Text = "Intensity (G)" };  //" + _myUnit + "
      chart.Options.Yaxis[1].Title = new AxisTitle() { Text = "Baseline (CLF)" };
      await chart.UpdateSeriesAsync(true);
      //await chart.UpdateOptionsAsync(true, true, false);      
    }
    maxTime = DateTimeOffset.MinValue;
    return;
  }

  public void Dispose()
  {
    this.Dispose();
    timer?.Stop();
    timer = null;
  }
}