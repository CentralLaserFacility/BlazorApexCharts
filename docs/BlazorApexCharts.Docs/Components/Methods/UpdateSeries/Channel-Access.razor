@page "/methods/channel-access"
@using BlazorApexCharts.Docs.Data
@using System.Timers
@using Clf.ChannelAccess
@implements IDisposable

<h3>ChannelAccess</h3>
<DemoContainer>
  <ApexChart @ref=chart TItem="RealTimeSeries"
             Title="@_streamChannel.ChannelName.Name"
             XAxisType="XAxisType.Datetime"
             Options=options>

    <ApexPointSeries TItem="RealTimeSeries"
                     Items="generator.TimeSeries"
                     SeriesType="SeriesType.Line"
                     Color="#247BA0"
                     Name="Field Strength"
                     XValue="@(e => e.Date)"
                     YValue="@(e => e.Value)"
                     OrderBy="e=>e.X" />
    <!-- ApexPointSeries TItem="RealTimeSeries"
                     Items="generator.BaselineSeries"
                     SeriesType="SeriesType.Line"
                     Color="Black"
                     XValue="_AT(e => e.Date)"
                     YValue="_AT(e => e.Value)"
                     OrderBy="e=>e.X" / -->

  </ApexChart>
</DemoContainer>

@code {
  //NOTE: ~ dataPoints for LaserShot events to draw a vertical slice.

  //NOTE: ~  There is Dark/light theming

  private ApexChart<RealTimeSeries> chart;
  private ApexChartOptions<RealTimeSeries> options;
  private RealTimeSeriesGenerator generator = new RealTimeSeriesGenerator(60);
  private bool timerInitialized = false;
  private Timer timer;
  private DateTimeOffset maxTime;
  private int counter;
  private List<MagneticResult> dataset = new List<MagneticResult>();
  private ChannelsHandler _channelsHandler = new ChannelsHandler();
  private bool _isChannelUp = false;
  IChannel _streamChannel = null;
  double _myValue;
  (double Min, double Max) _myRange;    //TODO: Need to dynamically change range based on this tuple.
  string _myUnit = "";
  string _lastUnit;

  double _lastLowerRange;
  double _lastUpperRange;
  string _csvExportFileName = "C:/Temp/gaussData.";

  //TODO: Below for async event based timing - as per EventSpawned providing rather than consuming values.
  //protected override async Task OnInitializedAsync()
  protected override void OnInitialized()
  {
    //Set default graphing options
    _channelsHandler.InstallChannel(
      _streamChannel = Hub.GetOrCreateChannel("BENCH:HIRST1:val"),
      (isConnected, state) => { timerInitialized = ConnectionDidChange(isConnected); },
      (valueInfo, _) => { _myValue = (double)valueInfo.Value; _myUnit = EventSpawned(valueInfo.AuxiliaryInfo); }
    );

    //(isConnected, state) => { timerInitialized = ConnectionStatus(isConnected, state); },


    //POLLER vs SPAWNER...
    //_myValue = (double)valueInfo.Value
    //Task.Run(() => SpawnData(valueInfo.Value, DateTime.Now()))

    options = new ApexChartOptions<RealTimeSeries>();

    options.Xaxis = new XAxis
      {
        Title = new AxisTitle() { Text = "Time (sec) - Commenced @ " + DateTime.Now.ToString("G") },
        Range = generator.Range
      };

    options.Tooltip = new ApexCharts.Tooltip
      {
        X = new TooltipX { Format = @"hh:mm:ss.fff" }
      };
    options.Tooltip = new ApexCharts.Tooltip
      {
        Y = new TooltipY
        {
          Title = new TooltipYTitle { Formatter = @"function(name) { return name + ':' }" },
          Formatter = @"function(value, { series, seriesIndex, dataPointIndex, w }) { return value }"
        },
      };

    options.Tooltip = new ApexCharts.Tooltip()
      {
        FollowCursor = true,
        Theme = Mode.Light,
        Marker = new TooltipMarker() { FillColors = new List<string> { "#247BA0" } }
      };
    options.Xaxis.DecimalsInFloat = 2;
    options.Yaxis = new List<YAxis> {
      new YAxis {
        Title = new AxisTitle { Text = "Intensity", Style = new AxisTitleStyle { FontSize = "14px", Color = "lightgrey" } },
        Max = 30,
        Min = -30
      }
    };
    options.Stroke = new Stroke { Curve = Curve.Smooth, Colors = new List<string> { "#247BA0" } };
    options.Chart = new Chart
      {
        Animations = new Animations
        {
          Easing = Easing.Linear,
          DynamicAnimation = new DynamicAnimation
          {
            Speed = 950
          }
        },
        Toolbar = new Toolbar
        {
          Show = false,
          Export = new ExportOptions
          {
            Csv = new ExportCSV
            {
              Filename = _csvExportFileName + ".csv",
              HeaderCategory = "Magnetic data",
            },
            Png = new ExportPng { Filename = _csvExportFileName + ".png" },
            Svg = new ExportSvg { Filename = _csvExportFileName + ".svg" }
          }
        },
        Zoom = new Zoom
        {
          Enabled = true,
          AutoScaleYaxis = false
        }
      };
  }

  //protected bool ConnectionStatus(bool isChannelUp, ChannelState state)
  protected bool ConnectionDidChange(bool isChannelUp)
  {
    //TODO: DEBUG hook.
    _isChannelUp = isChannelUp;
    if (!isChannelUp) Console.Write("PV went offline @ " + DateTime.Now.ToString("G"));
    Task.Run(() => BlankGraph());  //Connection wobbles will spawn a new graph...
                                   //Console.Write("DEBUG :" + state.ChannelHasConnected);
    return isChannelUp;
  }

  protected void DoChartOffline()
  {
    //Do we want to Pause & Run or just BlankOut 'above' in disconnect type events
    Task.Run(() => UpdateChartSeries());
  }

  protected bool UnitsDidChange(string unit)
  {
    if (_lastUnit != unit)
    {
      _lastUnit = unit;
      Task.Run(() => BlankGraph());
      return true;
    }
    return false;
  }

  protected bool RangeDidChange(double lowerRange, double upperRange)
  {
    _myRange = (lowerRange, upperRange);
    if (_lastUpperRange != upperRange)
    {
      _lastUpperRange = upperRange;

      Task.Run(() => BlankGraph());
      return true;
    }
    if (_lastLowerRange != lowerRange)
    {
      _lastLowerRange = lowerRange;
      Task.Run(() => BlankGraph());
      return true;
    }
    return false;
  }

  //REFACTOR: Just return the unit, this is an exploration hook for debug.
  protected string EventSpawned(AuxiliaryInfo scalingUnits)
  {
    //Return value particulars to the relevant member variables.
    UnitsDidChange(scalingUnits.EGU);
    RangeDidChange((double)scalingUnits.LOPR, (double)scalingUnits.HOPR);

    if (chart != null)
    {
      chart.Options.Yaxis[0].Min = _myRange.Min;
      chart.Options.Yaxis[0].Max = _myRange.Max;
    }
    return scalingUnits.EGU;
  }

  protected override void OnAfterRender(bool firstRender)
  {
    if (firstRender && !timerInitialized)
    {
      timerInitialized = true;
      timer = new Timer(500);
      timer.Elapsed += async delegate { await UpdateChartSeries(); };  //timer needs to be added against data device sent!!
      timer.Enabled = true;
      UnitsDidChange("");  //BlankGraph runner to actively set options
    }
  }

  private async Task UpdateChartSeries()
  {
    //Actively POLLING

    //TODO: Might want to key this to a timeStamp for Kafka?
    try
    {
      if (_isChannelUp)
      {
        if (counter > 21600) //Reset the chart at 6 hours - maximal run!!  TS: 15-Feb-2024
        {
          await BlankGraph();
        }

        //if (maxTime == DateTimeOffset.MinValue)
        //{
        //maxTime = generator.TimeSeries.Max(e => e.Date);
        //}

        maxTime = maxTime.AddSeconds(0.5);
        await chart.AppendDataAsync(
          new List<RealTimeSeries> {
            generator.GenerateNewPoint(maxTime, _myValue)
          }
        );
        counter++;
      }
    }
    catch (Exception ex)
    {
      //6hour runtime overflow!!
      Console.WriteLine(ex.Message);
    }
  }

  private async Task SpawnData(double val, DateTime actualTime)
  {
    //Just call from ChannelAccess eventHandler
    await chart.AppendDataAsync(
      new List<RealTimeSeries> {
        generator.GenerateNewPoint(maxTime, val)
              }
    );
  }

  private async Task BlankGraph()
  {
    try
    {
      counter = 0; //Zero counter as we are scaling at a different unit now + clear data..

      if (chart != null)
      {
        options.Tooltip = new ApexCharts.Tooltip
          {
            Y = new TooltipY
            {
              Title = new TooltipYTitle { Formatter = @"function(name) { return name + ':' }" },
              Formatter = @"function(value, { series, seriesIndex, dataPointIndex, w }) { return (Math.round(value * 100) / 100).toFixed(2) + '" + _myUnit + "'}"
            }
          };

        //Indicate PV/IOC is offline
        if (_isChannelUp)
        {
          //Sync after units change and state new measurement time.
          chart.Options.Xaxis.Title = new AxisTitle() { Text = "Time (sec) - Commenced @ " + DateTime.Now.ToString("G") };          
          chart.Options.Chart.Background = "#F6F8FA";
        } else {
          chart.Options.Xaxis.Title = new AxisTitle() { Text = "NO DATA - Commenced @ " + DateTime.Now.ToString("G") };
          chart.Options.Chart.Background = "#E0B0FF";          
        }

        if (chart.Options.Yaxis != null)
        {
          chart.Options.Yaxis[0].Title = new AxisTitle() { Text = "Intensity (" + _myUnit + ")" };
          //Scaling from Gauss PV
          //chart.Options.Yaxis[0].Min = _myRange.Min;
          //chart.Options.Yaxis[0].Max = _myRange.Max;
        }
        //chart.Options.Yaxis[1].Title = new AxisTitle() { Text = "Baseline (CLF)" };

        await chart.UpdateOptionsAsync(true, true, false);
      }
      maxTime = DateTimeOffset.MinValue;
    }
    catch (Exception ex)
    {
      if (ex != null) { Console.WriteLine(ex.Message); }
    }
    return;
  }

  public void Dispose()
  {
    this.Dispose();
    timer?.Stop();
    timer = null;
  }
}